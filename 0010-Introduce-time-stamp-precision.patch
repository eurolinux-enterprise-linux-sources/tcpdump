From a4337ba91b4c066c8f24832095ca76634d4b894a Mon Sep 17 00:00:00 2001
From: Michal Sekletar <sekletar.m@gmail.com>
Date: Wed, 19 Mar 2014 14:14:25 +0100
Subject: [PATCH 10/15] Introduce --time-stamp-precision

A while ago we introduced new API in libpcap which made possible to
request time stamps with higher precision (nanoseconds). This commit
aims to move things forward and implement missing bits. It introduces
new long option --time-stamp-precision. Note that there is no equivalent
short option.

When used for a live capture tcpdump will ask the kernel for time stamp
with desired precision and tcpdump will print fraction part of the time
stamp using respective format. We currently support only microsecond and
nanosecond precision. In the future we might support even more granular
time stamp precision, but we should be fine to support only
microseconds and nanoseconds for now. libpcap doesn't provide anything
else at the moment anyway.

When used in combination with -r/-w options then we obtain time stamps
appropriately scaled up or down from libpcap. Also note that distinct
magic number is used for savefiles containing nanosecond time stamps.

(cherry picked from commit 52b27d11fc50ebc4f1fc54b53fd9437d62dd7f4a)

Conflicts:
        netdissect.h
        tcpdump.1.in
        tcpdump.c
        util.c
---
 netdissect.h |  1 +
 tcpdump.1.in |  9 +++++++++
 tcpdump.c    | 39 +++++++++++++++++++++++++++++++++++++--
 util.c       |  9 ++++++---
 4 files changed, 53 insertions(+), 5 deletions(-)

diff --git a/netdissect.h b/netdissect.h
index 2f80d95..3ff1b17 100644
--- a/netdissect.h
+++ b/netdissect.h
@@ -118,6 +118,7 @@ struct netdissect_options {
   int ndo_Wflag;          /* recycle output files after this number of files */
   int ndo_WflagChars;
   int ndo_suppress_default_print; /* don't use default_print() for unknown packet types */
+  int ndo_tstamp_precision;   /* requested time stamp precision */
   const char *ndo_dltname;
 
   char *ndo_espsecret;
diff --git a/tcpdump.1.in b/tcpdump.1.in
index 3980dcc..69c1984 100644
--- a/tcpdump.1.in
+++ b/tcpdump.1.in
@@ -370,6 +370,15 @@ List the supported time stamp types for the interface and exit.  If the
 time stamp type cannot be set for the interface, no time stamp types are
 listed.
 .TP
+.BI \-\-time\-stamp\-precision= tstamp_precision
+.PD
+Set the time stamp precision for the capture to
+\fItstamp_precision\fP. Currently supported are microseconds and
+nanoseconds. Note that availability of high precision time stamps (nanoseconds)
+and their actual accuracy is platform and HW dependent. Also note that when
+writing captures to the savefile, distinct magic number is used to distinguish
+savefiles which contains time stamps in nanoseconds.
+.TP
 .B \-K
 Don't attempt to verify IP, TCP, or UDP checksums.  This is useful for
 interfaces that perform some or all of those checksum calculation in
diff --git a/tcpdump.c b/tcpdump.c
index 6c00f0e..5643f70 100644
--- a/tcpdump.c
+++ b/tcpdump.c
@@ -73,6 +73,7 @@ extern int SIZE_BUF;
 #include <grp.h>
 #include <errno.h>
 #endif /* WIN32 */
+#include <getopt.h>
 
 
 #include "netdissect.h"
@@ -430,6 +431,12 @@ show_dlts_and_exit(pcap_t *pd)
 #define U_FLAG
 #endif
 
+#define OPTION_TSTAMP_PRECISION 130
+
+static struct option longopts[] = {
+	{ "time-stamp-precision", required_argument, NULL, OPTION_TSTAMP_PRECISION},
+};
+
 #ifndef WIN32
 /* Drop root privileges and chroot if necessary */
 static void
@@ -529,6 +536,18 @@ static int tcpdump_printf(netdissect_options *ndo _U_,
   return ret;
 }
 
+static int
+tstamp_precision_from_string(const char *precision)
+{
+	if (strncmp(precision, "nano", strlen("nano")) == 0)
+		return PCAP_TSTAMP_PRECISION_NANO;
+
+	if (strncmp(precision, "micro", strlen("micro")) == 0)
+		return PCAP_TSTAMP_PRECISION_MICRO;
+
+	return -EINVAL;
+}
+
 int
 main(int argc, char **argv)
 {
@@ -585,7 +604,7 @@ main(int argc, char **argv)
 
 	opterr = 0;
 	while (
-	    (op = getopt(argc, argv, "aA" B_FLAG "c:C:d" D_FLAG "eE:fF:G:i:" I_FLAG j_FLAG J_FLAG "KlLm:M:nNOpqr:Rs:StT:u" U_FLAG "vw:W:xXy:Yz:Z:")) != -1)
+               (op = getopt_long(argc, argv, "aA" B_FLAG "c:C:d" D_FLAG "eE:fF:G:i:" I_FLAG j_FLAG J_FLAG "KlLm:M:nNOpqr:Rs:StT:u" U_FLAG "vw:W:xXy:Yz:Z:", longopts, NULL)) != -1)
 		switch (op) {
 
 		case 'a':
@@ -930,6 +949,12 @@ main(int argc, char **argv)
 			}
 			break;
 
+		case OPTION_TSTAMP_PRECISION:
+			gndo->ndo_tstamp_precision = tstamp_precision_from_string(optarg);
+			if (gndo->ndo_tstamp_precision < 0)
+				error("unsupported time stamp precision");
+			break;
+
 		default:
 			usage();
 			/* NOTREACHED */
@@ -988,7 +1013,11 @@ main(int argc, char **argv)
 		if (setgid(getgid()) != 0 || setuid(getuid()) != 0 )
 			fprintf(stderr, "Warning: setgid/setuid failed !\n");
 #endif /* WIN32 */
-		pd = pcap_open_offline(RFileName, ebuf);
+		if (gndo->ndo_tstamp_precision == PCAP_TSTAMP_PRECISION_NANO)
+			pd = pcap_open_offline_with_tstamp_precision(RFileName, PCAP_TSTAMP_PRECISION_NANO, ebuf);
+		else
+			pd = pcap_open_offline_with_tstamp_precision(RFileName, PCAP_TSTAMP_PRECISION_MICRO, ebuf);
+
 		if (pd == NULL)
 			error("%s", ebuf);
 		dlt = pcap_datalink(pd);
@@ -1033,6 +1062,12 @@ main(int argc, char **argv)
 		if (Jflag)
 			show_tstamp_types_and_exit(device, pd);
 #endif
+		if (gndo->ndo_tstamp_precision == PCAP_TSTAMP_PRECISION_NANO) {
+			status = pcap_set_tstamp_precision(pd, PCAP_TSTAMP_PRECISION_NANO);
+			if (status != 0)
+                                error("%s: Can't set nanosecond time stamp precision: %s",
+					device, pcap_statustostr(status));
+                }
 
 		status = pcap_set_snaplen(pd, snaplen);
 		if (status != 0)
diff --git a/util.c b/util.c
index a2ef36d..6bc05c0 100644
--- a/util.c
+++ b/util.c
@@ -146,9 +146,12 @@ fn_printzp(register const u_char *s, register u_int n,
 char *
 ts_format(register int sec, register int usec)
 {
-        static char buf[sizeof("00:00:00.000000")];
-        (void)snprintf(buf, sizeof(buf), "%02d:%02d:%02d.%06u",
-               sec / 3600, (sec % 3600) / 60, sec % 60, usec);
+	static char buf[sizeof("00:00:00.000000000")];
+	const char *format = gndo->ndo_tstamp_precision == PCAP_TSTAMP_PRECISION_NANO ?
+                "%02d:%02d:%02d.%09u" : "%02d:%02d:%02d.%06u";
+
+	snprintf(buf, sizeof(buf), format,
+                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);
 
         return buf;
 }
-- 
1.8.3.1

